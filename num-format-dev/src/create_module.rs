use indexmap::IndexMap;
use proc_macro2::{Delimiter, Group, Ident, Literal, Span};
use quote::quote;

#[cfg(feature = "nightly")]
use crate::rustfmt::rustfmt;
use crate::utils::Format;

#[cfg(feature = "nightly")]
/// Takes the map returned from `parse_data` and turns it into a rust module.
pub fn create_module(data: &IndexMap<String, Format>) -> Result<String, anyhow::Error> {
    let s = _create_module(data)?;
    let s = rustfmt(s)?;
    Ok(s)
}

#[cfg(not(feature = "nightly"))]
/// Takes the map returned from `parse_data` and turns it into a rust module.
pub fn create_module(data: &IndexMap<String, Format>) -> Result<String, anyhow::Error> {
    let s = _create_module(data)?;
    Ok(s)
}

/// Takes the map returned from `parse_data` and turns it into a rust module.
fn _create_module(data: &IndexMap<String, Format>) -> Result<String, anyhow::Error> {
    let variant_names = data.keys().map(|s| Ident::new(s, Span::call_site()));

    let mut decimals = Vec::new();
    let mut groupings = Vec::new();
    let mut infinities = Vec::new();
    let mut minus_signs = Vec::new();
    let mut nans = Vec::new();
    let mut plus_signs = Vec::new();
    let mut separators = Vec::new();
    let mut from_strs = Vec::new();
    let mut names = Vec::new();
    let mut names2 = Vec::new();
    for (variant_name, format) in data.iter() {
        let key = Ident::new(variant_name, Span::call_site());

        // decimals
        let value = Literal::string(&format.dec.to_string());
        let group = Group::new(
            Delimiter::None,
            quote! {
                #key => #value,
            },
        );
        decimals.push(group);

        // groupings
        let value = format.grp.to_ident();
        let group = Group::new(
            Delimiter::None,
            quote! {
                #key => #value,
            },
        );
        groupings.push(group);

        // infinities
        let value = Literal::string(&format.inf);
        let group = Group::new(
            Delimiter::None,
            quote! {
                #key => #value,
            },
        );
        infinities.push(group);

        // minus_signs
        let value = Literal::string(&format.min);
        let group = Group::new(
            Delimiter::None,
            quote! {
                #key => #value,
            },
        );
        minus_signs.push(group);

        // nans
        let value = Literal::string(&format.nan);
        let group = Group::new(
            Delimiter::None,
            quote! {
                #key => #value,
            },
        );
        nans.push(group);

        // plus_signs
        let value = Literal::string(&format.pos);
        let group = Group::new(
            Delimiter::None,
            quote! {
                #key => #value,
            },
        );
        plus_signs.push(group);

        // separtors
        let value = Literal::string(&format.sep.to_string());
        let group = Group::new(
            Delimiter::None,
            quote! {
                #key => #value,
            },
        );
        separators.push(group);

        // from_strs
        let value = key.clone();
        let key2 = Literal::string(&format.identifier);
        let group = Group::new(
            Delimiter::None,
            quote! {
                #key2 => #value,
            },
        );
        from_strs.push(group);

        // names
        let value = Literal::string(&format.identifier);
        let group = Group::new(
            Delimiter::None,
            quote! {
                #key => #value,
            },
        );
        names.push(group);

        // names2
        names2.push(&format.identifier);
    }

    names2.sort();
    let names2 = names2.into_iter().map(|s| Literal::string(s));
    let names2_len = names2.len();

    let token_stream = quote! {
        //!Note: This module was autogenerated by num-format-dev.

        use core::str::FromStr;

        use crate::error::Error;
        use crate::format::Format;
        use crate::grouping::Grouping;
        use crate::strings::{
            DecimalStr, InfinityStr, MinusSignStr, NanStr, PlusSignStr, SeparatorStr
        };

        const AVAILABLE_NAMES: [&str; #names2_len] = [#(#names2),*];

        ///<b><u>A key type</u></b>. Represents formats from the [Unicode Consortium]'s
        ///[Common Locale Data Repository (CLDR)]. Implements [`Format`].
        ///
        ///# Example
        ///```
        ///use num_format::{Buffer, Locale};
        ///
        ///fn main() {
        ///    // Using the French format from the Unicode Common Locale Data Repository...
        ///    let mut buf = Buffer::new();
        ///    buf.write_formatted(&(-1000000), &Locale::fr);
        ///    assert_eq!("-1\u{202f}000\u{202f}000", buf.as_str());
        ///
        ///    // Note:
        ///    // U+202F is the "NARROW NO-BREAK SPACE" code point.
        ///    // When displayed to the screen, it looks like a space.
        ///}
        ///```
        ///
        /// [`Format`]: trait.Format.html
        /// [Common Locale Data Repository (CLDR)]: https://en.wikipedia.org/wiki/Common_Locale_Data_Repository
        /// [Unicode Consortium]: https://en.wikipedia.org/wiki/Unicode_Consortium
        #[allow(non_camel_case_types, missing_docs)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
        #[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
        pub enum Locale {
            #(#variant_names),*
        }

        impl Locale {
            /// Constructs a [`Locale`] from its name. For a list of available names, see
            /// [`available_names`].
            ///
            /// # Errors
            ///
            /// Returns an error if the name provided cannot be
            /// parsed into a [`Locale`].
            ///
            /// [`available_names`]: enum.Locale.html#method.available_names
            /// [`Locale`]: enum.Locale.html
            pub fn from_name<S>(name: S) -> Result<Locale, Error>
                where S: AsRef<str>,
            {
                let name = name.as_ref();
                name.parse::<Locale>()
            }

            /// Returns a static slice of all available names.
            pub fn available_names() -> &'static [&'static str] {
                &AVAILABLE_NAMES
            }

            /// Returns the locale's decimal representation.
            pub fn decimal(&self) -> &'static str {
                use self::Locale::*;
                match self {
                    #(#decimals)*
                }
            }

            /// Returns the locale's [`Grouping`].
            ///
            /// [`Grouping`]: enum.Grouping.html
            pub fn grouping(&self) -> Grouping {
                use self::Grouping::*;
                use self::Locale::*;
                match self {
                    #(#groupings)*
                }
            }

            /// Returns the locale's infinity representation.
            pub fn infinity(&self) -> &'static str {
                use self::Locale::*;
                match self {
                    #(#infinities)*
                }
            }

            /// Returns the locale's minus sign representation.
            pub fn minus_sign(&self) -> &'static str {
                use self::Locale::*;
                match self {
                    #(#minus_signs)*
                }
            }

            /// Returns the locale's name.
            pub fn name(&self) -> &'static str {
                use self::Locale::*;
                match self {
                    #(#names)*
                }
            }

            /// Returns the locale's NaN representation.
            pub fn nan(&self) -> &'static str {
                use self::Locale::*;
                match self {
                    #(#nans)*
                }
            }

            /// Returns the locale's plus sign representation.
            pub fn plus_sign(&self) -> &'static str {
                use self::Locale::*;
                match self {
                    #(#plus_signs)*
                }
            }

            /// Returns the locale's separator representation, if any.
            pub fn separator(&self) -> &'static str {
                use self::Locale::*;
                match self {
                    #(#separators)*
                }
            }
        }

        impl Format for Locale {
            #[inline(always)]
            fn decimal(&self) -> DecimalStr<'_> {
                DecimalStr::new(self.decimal()).unwrap()
            }

            #[inline(always)]
            fn grouping(&self) -> Grouping {
                self.grouping()
            }

            #[inline(always)]
            fn infinity(&self) -> InfinityStr<'_> {
                InfinityStr::new(self.infinity()).unwrap()
            }

            #[inline(always)]
            fn minus_sign(&self) -> MinusSignStr<'_> {
                MinusSignStr::new(self.minus_sign()).unwrap()
            }

            #[inline(always)]
            fn nan(&self) -> NanStr<'_> {
                NanStr::new(self.nan()).unwrap()
            }

            #[inline(always)]
            fn plus_sign(&self) -> PlusSignStr<'_> {
                PlusSignStr::new(self.plus_sign()).unwrap()
            }

            #[inline(always)]
            fn separator(&self) -> SeparatorStr<'_> {
                SeparatorStr::new(self.separator()).unwrap()
            }
        }

        impl FromStr for Locale {
            type Err = Error;

            /// Same as [`from_name`].
            ///
            /// [`from_name`]: enum.Locale.html#method.from_name
            fn from_str(s: &str) -> Result<Self, Self::Err> {
                use self::Locale::*;
                let locale = match s {
                    #(#from_strs)*
                    _ => return Err(Error::parse_locale(s)),
                };
                Ok(locale)
            }
        }
    };

    let s = format!("{}", &token_stream);
    Ok(s)
}
